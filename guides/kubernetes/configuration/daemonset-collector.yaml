enabled: true
mode: daemonset

# Enabling presets automatically configures the necessary service accounts 
# and sane defaults
presets:
  kubernetesAttributes:
    enabled: true
  hostMetrics:
    enabled: true
  kubeletMetrics:
    enabled: true

extraEnvs:
  - name: DD_API_KEY
    valueFrom:
      secretKeyRef:
        name: datadog-secret
        key: api-key
  - name: CLUSTER_NAME
    valueFrom: 

config:
  receivers:
    hostmetrics:
      scrapers:
        cpu:
          metrics:
            system.cpu.logical.count:
              enabled: true # this is disabled by default, but we need to map system.cpu.num_cores

    kubeletstats:
      collection_interval: 15s
      auth_type: 'serviceAccount'
      endpoint: '${env:K8S_NODE_NAME}:10250'
      node: '${env:K8S_NODE_NAME}'
      insecure_skip_verify: true
      metric_groups:
        - node
        - pod
        - container
        - volume
      metrics:
        k8s.container.cpu.node.utilization:
          enabled: true
        k8s.pod.cpu.node.utilization:
          enabled: true
        k8s.container.memory.node.utilization:
          enabled: true
        k8s.pod.memory.node.utilization:
          enabled: true
          
  processors:
    batch: {}
    cumulativetodelta: {}
    deltatorate:
      metrics:
        - k8s.pod.network.io
        - k8s.pod.network.errors

    resource:
      attributes:
        # Globally set k8s cluster name on all resources
        - key: k8s.cluster.name
          value: <YOUR K8S CLUSTER NAME HERE>
          action: "insert"

    k8sattributes:
      auth_type: "serviceAccount"
      extract:
        otel_annotations: true
        metadata:
          - k8s.pod.name
          - k8s.pod.uid
          - k8s.deployment.name
          - k8s.namespace.name
          - k8s.node.name
          - k8s.replicaset.name
          - k8s.statefulset.name
          - k8s.daemonset.name
          - service.namespace
          - k8s.container.name
          - service.name
          - service.version
          - service.instance.id
      passthrough: false

    # the order of resource detection is important as it will influence how attributes
    # like "host" are sourced
    resourcedetection:
      detectors: ["k8snode", "system", "ec2", "eks", "kubeadm"]
      override: false
    
    memory_limiter:
      check_interval: 5s
      limit_percentage: 75
      spike_limit_percentage: 15

  connectors:
    datadog/connector:
      traces:
  
  exporters:
    debug:
      verbosity: detailed
    datadog/exporter:
      api:
        site: datad0g.com
        key: ${env:DD_API_KEY}

  service:
    pipelines:
      traces: 
        receivers: [otlp]
        processors: [batch]
        exporters: [datadog/connector]

      metrics:
        receivers: [datadog/connector, otlp]
        processors: [resourcedetection, resource, k8sattributes, cumulativetodelta, deltatorate, batch]
        exporters: [debug, datadog/exporter]